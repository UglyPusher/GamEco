/// \[AI: PURPOSE] Первая версия модели труда и навыков в симуляции экономики.
/// \[AI: NOTE] Этот документ фиксирует предварительные размышления и архитектурные решения. Подлежит дальнейшему уточнению, обсуждению и валидации.

# Черновая модель труда, навыков и крафта

## 1. Навыки (skills)

* Каждый агент (особенно NPC) имеет множество навыков.
* Навык описывается парой: `уровень (level)` и `опыт (xp)`
* Навык растёт при использовании и деградирует при бездействии.

### Структура:

```cpp
struct AgentSkill {
    double level = 1.0;
    double xp = 0.0;
};
```

* Навыки хранятся в `std::unordered_map<std::string, AgentSkill>`
* Примеры категорий: "woodwork", "baking", "culture", "logistics"

## 2. Деградация и прокачка

* Все навыки постепенно теряют уровень (плавная деградация на каждом тике).
* Используемый навык получает xp и рост уровня.
* Рост замедляется с накоплением xp (затухающая отдача).
* \[AI: FUTURE] Требует уточнения модели роста: какие функции использовать (линейная, логарифмическая, асимптотическая?).
* \[AI: EXPLANATION] xp отражает накопленную практику (историю), а level — текущую эффективность. xp влияет на скорость роста, но не участвует напрямую в производительности.

### Методы:

```cpp
void decayAllSkills();
void reinforceSkill(const std::string& skillId, double effort);
double getSkillLevel(const std::string& skillId) const;
```

## 3. Привязка навыков к ресурсам

* Каждый `ResourceType` имеет `skillCategory`, определяющую, какой навык нужен для его создания.

```cpp
class ResourceType {
    std::string skillCategory;
};
```

## 4. Производительность труда

* Производительность в тике рассчитывается как:

```cpp
laborPower = baseLabor × skillLevel[категория]
```

* \[AI: DESIGN] Навык (`level`) влияет на текущую эффективность труда.
* \[AI: DESIGN] Опыт (`xp`) влияет на скорость роста `level`, но не на силу напрямую.
* \[AI: EXPLANATION] Даже если `level` растёт, выход продукции может меняться слабо при низком коэффициенте производственной эффективности или малом интервале симуляции.

## 5. Крафт как трудовой процесс

* Крафт требует:

  * материальных ресурсов
  * трудозатрат (в человеко-часах)
  * возможно — денег
* Крафт — многошаговый процесс: накапливается `laborProgress`

```cpp
struct CraftingTask {
    const ResourceType* target;
    uint64_t quantity;
    uint64_t totalLabor;
    uint64_t laborProgress = 0;
};
```

## 6. Индивидуальные и организационные агенты

* `Individual`-агенты (люди) имеют навыки и работают сами.
* `Delegating`-агенты (предприятия, сёла) используют вложенных агентов (рабочих).
* Режим определяется либо флагом `AgentMode`, либо стратегией `LaborStrategy`.

```cpp
enum class AgentMode { Individual, Delegating };
```

## 7. Доступ к навыкам

* Навыки **доступны извне** для оценки, например, при найме:

  * `getSkillLevel(cat)`
  * `getAllSkills()`
* Возможен интерфейс `ISkilledAgent` для прозрачности и модульности.

## 8. Вопросы и направления для уточнения

* Как отражать специализацию: один скилл растёт → другие падают?
* Как крафт масштабируется: параллелизм, ассистенты, машинные ускорители?
* Как ограничить переобучение? Нужно ли хранить "базовое предназначение"?
* Как соотносятся skillLevel и квалификация (рейтинг, профессия)?
* \[AI: FUTURE] Как будет вести себя кривая роста навыка при длительной практике? Например, человек работает год подряд в одной области — какой будет его уровень?
* \[AI: FUTURE] Нужно ли учитывать инерцию xp при возобновлении навыка после перерыва? Должен ли навык быстро восстанавливаться?
* \[AI: FUTURE] Может ли рост навыка привести к существенному увеличению выпуска продукции? Что ограничивает производственный рост?

/// \[AI: FUTURE] Все пункты подлежат уточнению после симуляции тестовых сценариев и UX-анализа баланса.
